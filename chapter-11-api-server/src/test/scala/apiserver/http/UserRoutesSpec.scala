package apiserver.http

import cats.effect._
import cats.effect.unsafe.implicits.global
import doobie._
import doobie.implicits._
import doobie.h2._
import org.http4s._
import org.http4s.circe.CirceEntityCodec._
import org.http4s.implicits._
import io.circe.generic.auto._
import io.circe.syntax._
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers
import org.scalatest.BeforeAndAfterEach
import apiserver.domain._
import apiserver.repository.DoobieUserRepository
import apiserver.service.UserServiceImpl

/**
 * Integration tests for HTTP routes.
 * 
 * Rust Comparison:
 * Similar to Rust HTTP integration tests with axum/actix:
 * 
 * #[tokio::test]
 * async fn test_create_user() {
 *     let app = Router::new()
 *         .route("/users", post(create_user))
 *         .with_state(app_state);
 *     
 *     let request = Request::builder()
 *         .uri("/users")
 *         .method("POST")
 *         .header("content-type", "application/json")
 *         .body(Body::from(r#"{"name":"Alice","email":"alice@example.com","age":30}"#))
 *         .unwrap();
 *     
 *     let response = app.oneshot(request).await.unwrap();
 *     assert_eq!(response.status(), StatusCode::CREATED);
 * }
 */
class UserRoutesSpec extends AnyFlatSpec with Matchers with BeforeAndAfterEach {

  // Create H2 transactor for testing
  val transactor: Transactor[IO] = Transactor.fromDriverManager[IO](
    driver = "org.h2.Driver",
    url = "jdbc:h2:mem:testdb_http;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false",
    user = "sa",
    password = "",
    logHandler = None
  )

  val repository = new DoobieUserRepository()
  val service = new UserServiceImpl(repository)
  val routes = new UserRoutes(service, transactor).routes.orNotFound

  // Setup: Create table before each test
  override def beforeEach(): Unit = {
    val setup = sql"""
      DROP TABLE IF EXISTS users;
      CREATE TABLE users (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        email VARCHAR(255) NOT NULL UNIQUE,
        age INT NOT NULL CHECK (age >= 0 AND age <= 150),
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      )
    """.update.run

    setup.transact(transactor).unsafeRunSync()
  }

  "GET /health" should "return healthy status" in {
    val request = Request[IO](Method.GET, uri"/health")

    val response = routes.run(request).unsafeRunSync()
    response.status shouldBe Status.Ok
    
    val health = response.as[HealthCheckResponse].unsafeRunSync()
    health.status shouldBe "healthy"
    health.timestamp should be > 0L
  }

  "POST /users" should "create a new user" in {
    val createReq = CreateUserRequest("Alice", "alice@example.com", 30)
    val request = Request[IO](Method.POST, uri"/users")
      .withEntity(createReq.asJson)

    val response = routes.run(request).unsafeRunSync()
    response.status shouldBe Status.Created
    
    val user = response.as[User].unsafeRunSync()
    user.name shouldBe "Alice"
    user.email shouldBe "alice@example.com"
    user.age shouldBe 30
    user.id should be > 0L
  }

  it should "return 400 for invalid data" in {
    val createReq = CreateUserRequest("", "invalid-email", -1)
    val request = Request[IO](Method.POST, uri"/users")
      .withEntity(createReq.asJson)

    val response = routes.run(request).unsafeRunSync()
    response.status shouldBe Status.BadRequest
  }

  "GET /users" should "return empty list when no users" in {
    val request = Request[IO](Method.GET, uri"/users")

    val response = routes.run(request).unsafeRunSync()
    response.status shouldBe Status.Ok
    
    val users = response.as[List[User]].unsafeRunSync()
    users shouldBe empty
  }

  it should "return all users" in {
    val createReq1 = CreateUserRequest("Alice", "alice@example.com", 30)
    val createReq2 = CreateUserRequest("Bob", "bob@example.com", 25)

    // Create users
    routes.run(Request[IO](Method.POST, uri"/users").withEntity(createReq1.asJson)).unsafeRunSync()
    routes.run(Request[IO](Method.POST, uri"/users").withEntity(createReq2.asJson)).unsafeRunSync()
    
    // Get all users
    val response = routes.run(Request[IO](Method.GET, uri"/users")).unsafeRunSync()
    response.status shouldBe Status.Ok
    
    val users = response.as[List[User]].unsafeRunSync()
    users should have size 2
  }

  "GET /users/:id" should "return user when exists" in {
    val createReq = CreateUserRequest("Alice", "alice@example.com", 30)

    val createResponse = routes.run(Request[IO](Method.POST, uri"/users").withEntity(createReq.asJson)).unsafeRunSync()
    val createdUser = createResponse.as[User].unsafeRunSync()
    
    val getResponse = routes.run(Request[IO](Method.GET, Uri.unsafeFromString(s"/users/${createdUser.id}"))).unsafeRunSync()
    getResponse.status shouldBe Status.Ok
    
    val user = getResponse.as[User].unsafeRunSync()
    user.id shouldBe createdUser.id
    user.name shouldBe "Alice"
  }

  it should "return 404 when user doesn't exist" in {
    val request = Request[IO](Method.GET, uri"/users/999")

    val response = routes.run(request).unsafeRunSync()
    response.status shouldBe Status.NotFound
  }

  "PUT /users/:id" should "update existing user" in {
    val createReq = CreateUserRequest("Alice", "alice@example.com", 30)
    val updateReq = UpdateUserRequest("Alice Smith", "alice.smith@example.com", 31)

    val createResponse = routes.run(Request[IO](Method.POST, uri"/users").withEntity(createReq.asJson)).unsafeRunSync()
    val createdUser = createResponse.as[User].unsafeRunSync()
    
    val updateResponse = routes.run(
      Request[IO](Method.PUT, Uri.unsafeFromString(s"/users/${createdUser.id}"))
        .withEntity(updateReq.asJson)
    ).unsafeRunSync()
    
    updateResponse.status shouldBe Status.Ok
    
    val user = updateResponse.as[User].unsafeRunSync()
    user.name shouldBe "Alice Smith"
    user.email shouldBe "alice.smith@example.com"
    user.age shouldBe 31
  }

  it should "return 404 when updating non-existent user" in {
    val updateReq = UpdateUserRequest("Alice", "alice@example.com", 30)
    val request = Request[IO](Method.PUT, uri"/users/999")
      .withEntity(updateReq.asJson)

    val response = routes.run(request).unsafeRunSync()
    response.status shouldBe Status.NotFound
  }

  "DELETE /users/:id" should "delete existing user" in {
    val createReq = CreateUserRequest("Alice", "alice@example.com", 30)

    val createResponse = routes.run(Request[IO](Method.POST, uri"/users").withEntity(createReq.asJson)).unsafeRunSync()
    val createdUser = createResponse.as[User].unsafeRunSync()
    
    val deleteResponse = routes.run(Request[IO](Method.DELETE, Uri.unsafeFromString(s"/users/${createdUser.id}"))).unsafeRunSync()
    deleteResponse.status shouldBe Status.Ok
    
    val getResponse = routes.run(Request[IO](Method.GET, Uri.unsafeFromString(s"/users/${createdUser.id}"))).unsafeRunSync()
    getResponse.status shouldBe Status.NotFound // User should not exist after deletion
  }

  it should "return 404 when deleting non-existent user" in {
    val request = Request[IO](Method.DELETE, uri"/users/999")

    val response = routes.run(request).unsafeRunSync()
    response.status shouldBe Status.NotFound
  }
}
