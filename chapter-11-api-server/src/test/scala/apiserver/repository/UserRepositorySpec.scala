package apiserver.repository

import cats.effect._
import cats.effect.unsafe.implicits.global
import doobie._
import doobie.implicits._
import doobie.h2._
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers
import org.scalatest.BeforeAndAfterEach
import apiserver.domain._

/**
 * Integration tests for UserRepository with H2 in-memory database.
 * 
 * Rust Comparison:
 * Similar to Rust integration tests in tests/ directory:
 * 
 * #[sqlx::test]
 * async fn test_repository_create_user() {
 *     let pool = PgPool::connect("postgresql://...").await.unwrap();
 *     let repo = UserRepository::new(pool);
 *     
 *     let user = repo.create(CreateUserRequest {
 *         name: "Alice".to_string(),
 *         email: "alice@example.com".to_string(),
 *         age: 30,
 *     }).await.unwrap();
 *     
 *     assert_eq!(user.name, "Alice");
 * }
 */
class UserRepositorySpec extends AnyFlatSpec with Matchers with BeforeAndAfterEach {

  // Create H2 transactor for testing
  val transactor: Transactor[IO] = Transactor.fromDriverManager[IO](
    driver = "org.h2.Driver",
    url = "jdbc:h2:mem:testdb;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false",
    user = "sa",
    password = "",
    logHandler = None
  )

  val repository = new DoobieUserRepository()

  // Setup: Create table before each test
  override def beforeEach(): Unit = {
    val setup = sql"""
      DROP TABLE IF EXISTS users;
      CREATE TABLE users (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        email VARCHAR(255) NOT NULL UNIQUE,
        age INT NOT NULL CHECK (age >= 0 AND age <= 150),
        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
      )
    """.update.run

    setup.transact(transactor).unsafeRunSync()
  }

  // Teardown: Drop table after each test
  override def afterEach(): Unit = {
    val teardown = sql"DROP TABLE IF EXISTS users".update.run
    teardown.transact(transactor).unsafeRunSync()
  }

  "UserRepository.create" should "insert a new user" in {
    val request = CreateUserRequest("Alice", "alice@example.com", 30)

    val result = repository.create(request)
      .value
      .transact(transactor)
      .unsafeRunSync()

    result match {
      case Right(user) =>
        user.name shouldBe "Alice"
        user.email shouldBe "alice@example.com"
        user.age shouldBe 30
        user.id should be > 0L
      case Left(error) =>
        fail(s"Expected Right but got Left: $error")
    }
  }

  it should "generate unique IDs for multiple users" in {
    val request1 = CreateUserRequest("Alice", "alice@example.com", 30)
    val request2 = CreateUserRequest("Bob", "bob@example.com", 25)

    val result = (for {
      user1 <- repository.create(request1)
      user2 <- repository.create(request2)
    } yield (user1.id, user2.id))
      .value
      .transact(transactor)
      .unsafeRunSync()

    result match {
      case Right((id1, id2)) =>
        id1 should not equal id2
      case Left(error) =>
        fail(s"Expected Right but got Left: $error")
    }
  }

  "UserRepository.findById" should "return user when exists" in {
    val request = CreateUserRequest("Alice", "alice@example.com", 30)

    val result = (for {
      created <- repository.create(request)
      found <- repository.findById(created.id)
    } yield (created, found))
      .value
      .transact(transactor)
      .unsafeRunSync()

    result match {
      case Right((created, found)) =>
        found.id shouldBe created.id
        found.name shouldBe created.name
        found.email shouldBe created.email
        found.age shouldBe created.age
      case Left(error) =>
        fail(s"Expected Right but got Left: $error")
    }
  }

  it should "return UserNotFound when ID doesn't exist" in {
    val result = repository.findById(999L)
      .value
      .transact(transactor)
      .unsafeRunSync()

    result match {
      case Left(DomainError.UserNotFound(id)) =>
        id shouldBe 999L
      case Right(_) =>
        fail("Expected UserNotFound but got Right")
      case Left(other) =>
        fail(s"Expected UserNotFound but got: $other")
    }
  }

  "UserRepository.findAll" should "return empty list when no users" in {
    val result = repository.findAll()
      .value
      .transact(transactor)
      .unsafeRunSync()

    result match {
      case Right(users) =>
        users shouldBe empty
      case Left(error) =>
        fail(s"Expected Right but got Left: $error")
    }
  }

  it should "return all users" in {
    val request1 = CreateUserRequest("Alice", "alice@example.com", 30)
    val request2 = CreateUserRequest("Bob", "bob@example.com", 25)

    val result = (for {
      _ <- repository.create(request1)
      _ <- repository.create(request2)
      users <- repository.findAll()
    } yield users)
      .value
      .transact(transactor)
      .unsafeRunSync()

    result match {
      case Right(users) =>
        users should have size 2
        users.map(_.name) should contain allOf ("Alice", "Bob")
      case Left(error) =>
        fail(s"Expected Right but got Left: $error")
    }
  }

  "UserRepository.update" should "update existing user" in {
    val createReq = CreateUserRequest("Alice", "alice@example.com", 30)
    val updateReq = UpdateUserRequest("Alice Smith", "alice.smith@example.com", 31)

    val result = (for {
      created <- repository.create(createReq)
      updated <- repository.update(created.id, updateReq)
    } yield (created, updated))
      .value
      .transact(transactor)
      .unsafeRunSync()

    result match {
      case Right((created, updated)) =>
        updated.id shouldBe created.id
        updated.name shouldBe "Alice Smith"
        updated.email shouldBe "alice.smith@example.com"
        updated.age shouldBe 31
        updated.createdAt shouldBe created.createdAt
        updated.updatedAt should be > created.updatedAt
      case Left(error) =>
        fail(s"Expected Right but got Left: $error")
    }
  }

  it should "return UserNotFound when updating non-existent user" in {
    val updateReq = UpdateUserRequest("Alice", "alice@example.com", 30)

    val result = repository.update(999L, updateReq)
      .value
      .transact(transactor)
      .unsafeRunSync()

    result match {
      case Left(DomainError.UserNotFound(id)) =>
        id shouldBe 999L
      case Right(_) =>
        fail("Expected UserNotFound but got Right")
      case Left(other) =>
        fail(s"Expected UserNotFound but got: $other")
    }
  }

  "UserRepository.delete" should "delete existing user" in {
    val request = CreateUserRequest("Alice", "alice@example.com", 30)

    // Create and delete a user
    val deleteResult = (for {
      created <- repository.create(request)
      _ <- repository.delete(created.id)
    } yield created.id)
      .value
      .transact(transactor)
      .unsafeRunSync()

    deleteResult should matchPattern { case Right(_) => }
    
    // Verify user is not found after deletion
    deleteResult match {
      case Right(id) =>
        val findResult = repository.findById(id)
          .value
          .transact(transactor)
          .unsafeRunSync()
        
        findResult should matchPattern { case Left(DomainError.UserNotFound(_)) => }
      case Left(error) =>
        fail(s"Delete failed: $error")
    }
  }

  it should "return UserNotFound when deleting non-existent user" in {
    val result = repository.delete(999L)
      .value
      .transact(transactor)
      .unsafeRunSync()

    result match {
      case Left(DomainError.UserNotFound(id)) =>
        id shouldBe 999L
      case Right(_) =>
        fail("Expected UserNotFound but got Right")
      case Left(other) =>
        fail(s"Expected UserNotFound but got: $other")
    }
  }

  "UserRepository transactions" should "rollback on error" in {
    val request1 = CreateUserRequest("Alice", "alice@example.com", 30)
    val request2 = CreateUserRequest("Bob", "alice@example.com", 25) // Duplicate email

    // This should fail due to unique constraint
    val result = (for {
      _ <- repository.create(request1)
      _ <- repository.create(request2) // Should fail
    } yield ())
      .value
      .transact(transactor)
      .attempt
      .unsafeRunSync()

    // Verify first insert succeeded (not part of same transaction in this setup)
    val users = repository.findAll()
      .value
      .transact(transactor)
      .unsafeRunSync()

    users match {
      case Right(list) =>
        list should have size 1 // Only Alice should exist
      case Left(error) =>
        fail(s"Expected Right but got Left: $error")
    }
  }
}
